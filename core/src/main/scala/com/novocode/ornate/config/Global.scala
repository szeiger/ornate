package com.novocode.ornate.config

import java.net.{URI, URLEncoder}
import java.util.concurrent.{ThreadFactory, ThreadPoolExecutor, LinkedBlockingQueue, TimeUnit}

import com.novocode.ornate._
import com.novocode.ornate.theme.Theme
import com.novocode.ornate.config.ConfigExtensionMethods.configExtensionMethods
import org.commonmark.renderer.html.HtmlRenderer.HtmlRendererExtension
import org.commonmark.parser.Parser.ParserExtension

import scala.jdk.CollectionConverters._
import better.files._
import com.typesafe.config.{Config, ConfigFactory, ConfigValue}

import scala.collection.generic.CanBuildFrom
import scala.collection.mutable
import scala.collection.mutable.ListBuffer
import scala.concurrent.duration.Duration
import scala.concurrent.{Await, ExecutionContext, Future}

class Global(startDir: File, confFile: Option[File], overrides: Config = ConfigFactory.empty()) extends Logging {
  val (referenceConfig: ReferenceConfig, userConfig: UserConfig) = {
    val ref = ConfigFactory.parseResources(getClass, "/ornate-reference.conf")
    val refC = new ReferenceConfig(ref.resolve(), this)
    confFile.flatMap { f =>
      if(f.exists) {
        logger.info(s"Using configuration file $f")
        Some(f)
      } else {
        logger.info(s"Configuration file $f not found, using defaults from ornate-reference.conf")
        None
      }
    } match {
      case Some(f) =>
        val c = ConfigFactory.parseFile(f.toJava)
        (refC, new UserConfig(overrides.withFallback(c).withFallback(ref).resolve(), this))
      case None =>
        (refC, new UserConfig(overrides.withFallback(ref).resolve(), this))
    }
  }

  logger.debug("Source dir is: " + userConfig.sourceDir)
  logger.debug("Target dir is: " + userConfig.targetDir)

  def getFile(path: String): File = startDir / path

  private val cachedExtensions = new mutable.HashMap[String, Option[AnyRef]]

  private[config] def getCachedExtensionObject(co: ConfiguredObject): Option[AnyRef] = cachedExtensions.synchronized {
    cachedExtensions.getOrElseUpdate(co.className, {
      try {
        val cls = Class.forName(co.className)
        if(classOf[Extension].isAssignableFrom(cls)) {
          try {
            val cons = cls.getConstructor(classOf[ConfiguredObject])
            Some(cons.newInstance(co).asInstanceOf[Extension])
          } catch { case _: NoSuchMethodException =>
            Some(cls.newInstance().asInstanceOf[Extension])
          }
        } else // CommonMark extension
          Some(cls.getMethod("create").invoke(null))
      } catch { case ex: Exception =>
        logger.error(s"Error instantiating extension class ${co.className} -- disabling extension", ex)
        None
      }
    })
  }

  @volatile lazy val theme: Theme = {
    val cl = userConfig.theme.className
    logger.debug(s"Creating theme from class $cl")
    Class.forName(cl).getConstructor(classOf[Global]).newInstance(this).asInstanceOf[Theme]
  }

  @volatile lazy val executionContext: ExecutionContext = {
    val num = userConfig.numThreads
    logger.debug(s"Using $num threads")
    object TF extends ThreadFactory {
      override def newThread(r: Runnable): Thread = {
        val t = new Thread(r)
        t.setDaemon(true)
        t
      }
    }
    val pool = new ThreadPoolExecutor(num, num, 1L, TimeUnit.SECONDS, new LinkedBlockingQueue[Runnable](), TF)
    ExecutionContext.fromExecutor(pool)
  }

  /** Run a mapping function in parallel using the configured `executionContext` */
  def parMap[T, R](coll: Iterable[T])(f: T => R): Vector[R] = {
    implicit val ec = executionContext
    val fs: Vector[Future[R]] = coll.map(x => Future(f(x))).toVector
    fs.foreach(f => Await.ready(f, Duration.Inf))
    fs.map(f => f.value.get.get)
  }

  /** Find all sources in global.sourceDir as (file, suffix, uri) */
  def findSources: Vector[(File, String, URI)] = {
    val dir = userConfig.sourceDir
    val suffix = ".md"
    dir.collectChildren(f => f.isRegularFile && f.name.endsWith(suffix)).toSeq.map { f =>
      (f, suffix, Util.sourceFileURI(dir, f))
    }.toVector
  }

  def findStaticResources: Vector[(File, URI)] = {
    val dir = userConfig.resourceDir
    userConfig.excludeResources.filter(dir).collect {
      case f if f.isRegularFile => (f, Util.sourceFileURI(dir, f))
    }
  }
}

/** Reference configuration, used for extra pages generated by themes */
class ReferenceConfig(val raw: Config, global: Global) {
  def getExtensions(names: Iterable[String]): Extensions = {
    val normalized = objectKind("extension").normalizeAndCreate(names)
    new Extensions(normalized.map(co => (co, global.getCachedExtensionObject(co))))
  }

  def parsePageConfig(hocon: String): Config =
    ConfigFactory.parseString(hocon).withFallback(raw).resolve()

  private[this] val cachedObjectKinds = new mutable.HashMap[String, ConfiguredObjectKind]

  def objectKind(prefix: String): ConfiguredObjectKind = cachedObjectKinds.synchronized {
    cachedObjectKinds.getOrElseUpdate(prefix, {
      val m = raw.getConfigMapOr(s"global.${prefix}Aliases").mapValues(_.unwrapped.toString)
      new ConfiguredObjectKind(prefix, m.toMap, raw, global)
    })
  }
}

/** User configuration */
class UserConfig(raw: Config, global: Global) extends ReferenceConfig(raw, global) {
  val sourceDir: File = global.getFile(raw.getString("global.sourceDir"))
  val targetDir: File = global.getFile(raw.getString("global.targetDir"))
  val resourceDir: File = global.getFile(raw.getString("global.resourceDir"))
  val tocMaxLevel: Int = raw.getInt("global.tocMaxLevel")
  val tocMergeFirst: Boolean = raw.getBoolean("global.tocMergeFirst")
  val excludeResources: FileMatcher = new FileMatcher(raw.getStringList("global.excludeResources").asScala.toVector)
  val allowTargetLinks: Boolean = raw.getBoolean("global.allowTargetLinks")
  val numThreads: Int = raw.getIntOr("global.numThreads", Runtime.getRuntime.availableProcessors)

  val theme = objectKind("theme").singleton

  val toc: Option[Vector[ConfigValue]] = raw.getListOpt("global.toc").map(_.toVector)
}

class ConfiguredObject(val prefix: String, val name: String, val className: String, rootConfig: Config, val global: Global) {
  def getConfig(pageConfig: Config): Config = pageConfig.getConfigOr(s"$prefix.$name")
  lazy val config: Config = getConfig(rootConfig)

  /** Create a memoization of a parsed site config which avoids reparsing when the page config is identical */
  def memoizeParsed[T](f: Config => T): (Config => T) = new Function[Config, T] {
    lazy val siteConfig = f(config)
    def apply(pageConfig: Config): T = {
      val c = getConfig(pageConfig)
      if(c eq config) siteConfig else f(c)
    }
  }
}

class ConfiguredObjectKind(val prefix: String, aliases: Map[String, String], rootConfig: Config, global: Global) {
  private[this] lazy val reverse = aliases.map { case (a, c) => (c, a) }

  def dealias(cls: String): String = aliases.getOrElse(cls, cls)
  def alias(alias: String): String = reverse.getOrElse(alias, alias)

  def create(alias: String): ConfiguredObject =
    new ConfiguredObject(prefix, alias, dealias(alias), rootConfig, global)

  @volatile lazy val singleton: ConfiguredObject = create(rootConfig.getString(s"global.$prefix"))

  def normalizeAndCreate(names: Iterable[String]): Vector[ConfiguredObject] = {
    val b = new mutable.ListBuffer[String]
    names.foreach { s =>
      if(s.startsWith("-")) b -= dealias(s.substring(1))
      else b += dealias(s)
    }
    b.map(cls => new ConfiguredObject(prefix, alias(cls), cls, rootConfig, global)).toVector
  }
}
